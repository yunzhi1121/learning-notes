## SQL

### 通用语法

* SQL语句可以单行或多行书写，以分号结尾。
* SQL语句可以使用空格/缩进来增强语句的可读性。
* MySQL数据库的SQL语句不区分大小写。
* 注释：
  1. 单行注释：-- 注释内容 或 # 注释内容(MySQL特有)
  2. 多行注释： /* 注释内容 */

### 分类


分类 | 全称 | 说明
------- | ------- | -------
DDL | Data Definition Language | 数据定义语言，用来定义数据库对象(数据库，表，字段)
DML | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改
DQL | Data Query Language | 数据查询语言，用来查询数据库中表的记录
DCL | Data Control Language | 数据控制语言，用来创建数据库用户、控制数据库的访问权限


### DDL

#### 库操作

DDL 英文全称是 Data Definition Language，数据定义语言，用来定义数据库对象(数据库、表)。

* 查询所有数据库：`show databases;`
* 查询当前数据库：`select database();`
* 创建数据库：`create  database [ if  not  exists ]   数据库名 ;`
* 使用数据库：`use  数据库名 ;`
* 删除数据库：`drop  database [ if exists ]   数据库名;`

> 上述语法中的 `database`，也可以替换成 `schema`。如：`create schema  db01;`


#### 表操作

**创建**：
```sql
create table  表名(
	字段1  字段类型  [ 约束 ]  [ comment  字段1注释 ] ,
	......
	字段n  字段类型  [ 约束 ]  [ comment  字段n注释 ] 
) [ comment  表注释 ] ;

```

**约束**：

* 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。
* 目的：保证数据库中数据的正确性、有效性和完整性。


约束 | 描述 | 关键字
------- | ------- | -------
非空约束 | 限制该字段值不能为null | `not null`
唯一约束 | 保证字段的所有数据都是唯一、不重复的 | `unique`
主键约束 | 主键是一行数据的唯一标识，要求非空且唯一 | `primary key`
默认约束 | 保存数据时，如果未指定该字段值，则采用默认值 | `default`
外键约束 | 让两张表的数据建立连接，保证数据的一致性和完整性 | `foreign key`


**数据类型**：

MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。

⬇️**数值类型**

类型 | 大小(byte) | 有符号(SIGNED)范围 | 无符号(UNSIGNED)范围 | 描述 | 备注
------- | ------- | ------- | ------- | ------- | -------
**tinyint** | 1 | (-128，127) | (0，255) | 小整数值 | 
smallint | 2 | (-32768，32767) | (0，65535) | 大整数值 | 
mediumint | 3 | (-8388608，8388607) | (0，16777215) | 大整数值 | 
**int** | 4 | (-2147483648，2147483647) | (0，4294967295) | 大整数值 | 
**bigint** | 8 | (-2^63 ，2^63 - 1) | (0，2^64 - 1) | 极大整数值 | 
float | 4 | (-3.402823466 E+38，3.402823466351 E+38) | 0 和 (1.175494351 E-38，3.402823466 E+38) | 单精度浮点数值 | float(5,2)：5表示整个数字长度，2 表示小数位个数
double | 8 | (-1.7976931348623157 E+308，1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) | 双精度浮点数值 | double(5,2)：5表示整个数字长度，2 表示小数位个数
decimal |  |  |  | 小数值(精度更高) | decimal(5,2)：5表示整个数字长度，2 表示小数位个数



⬇️**字符串类型**
类型 | 大小 | 描述
------- | ------- | -------
**char** | 0-255 bytes | 定长字符串
**varchar** | 0-65535 bytes | 变长字符串
tinyblob | 0-255 bytes | 不超过255个字符的二进制数据
tinytext | 0-255 bytes | 短文本字符串
blob | 0-65 535 bytes | 二进制形式的长文本数据
text | 0-65 535 bytes | 长文本数据
mediumblob | 0-16 777 215 bytes | 二进制形式的中等长度文本数据
mediumtext | 0-16 777 215 bytes | 中等长度文本数据
longblob | 0-4 294 967 295 bytes | 二进制形式的极大文本数据
longtext | 0-4 294 967 295 bytes | 极大文本数据


⬇️**日期类型**

类型 | 大小(byte) | 范围 | 格式 | 描述
------- | ------- | ------- | ------- | -------
**date** | 3 | 1000-01-01 至 9999-12-31 | YYYY-MM-DD | 日期值
time | 3 | -838:59:59 至 838:59:59 | HH:MM:SS | 时间值或持续时间
year | 1 | 1901 至 2155 | YYYY | 年份值
**datetime** | 8 | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值
timestamp | 4 | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳

## 事务

**事务** 是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 **要么同时成功，要么同时失败**

事务可以保证数据库从一个一致性状态转向另一个一致性状态，即使是在系统发生故障或者并发访问的情况下也能保证

> 默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务

```sql
--开启事务（二选一）：
start transaction;  
begin;		

--提交事务：
commit;

--回滚事务：
rollback;
```

### 事务的四大特性

事务的四大特性也是关系型数据库的四大特性：

**ACID 特性** 
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）

ACID 是数据库事务管理的四大核心属性，确保数据可靠性： 
属性|中文|解释
---|---|---
A - Atomicity|原子性|操作要么全部执行，要么全部不执行（不允许部分成功）
C - Consistency|一致性|数据始终处于合法状态，事务完成后仍满足数据库规则
I - Isolation|隔离性|并发事务之间互不影响，避免读写冲突
D - Durability|持久性|一旦事务提交，数据永久写入，即使系统崩溃也不会丢失

#### 原子性

原子性意思是事务是一个不可分割的最小单元，要么所有操作全部提交commit，要么所有操作全部回滚rollback
**重要性**：原子性保证了不会有部分完成的任务，数据库不会出现不一致的中间状态，比如银行转账一边钱已经转出，一边没有入账这种情况
**实现机制**：实现机制是undo log日志，也就是回滚日志，当事务执行失败或者需要进行回滚操作的时候，数据库引擎会解析undo log日志，逆向执行操作，撤销所有修改

#### 一致性

一致性的意思是，数据库中的数据要满足`业务逻辑`，`约束`  和 `完整性`
**重要性**：通过约束数据状态的合法性，避免业务逻辑错误
**实现机制**：
1. 业务逻辑层面：应用层的逻辑规矩
2. 数据库约束：主键，外键，不为空，唯一等约束

#### 隔离性

隔离性就是在并发情况下每个事务都是被隔离开的，独立的，不会相互干扰
**重要性**：避免并发导致的数据混乱
**实现机制**：主要通过锁机制（Locking）和多版本并发控制(MVCC-Multi-VersionConcurrencyControl)来实现。

#### 持久性

持久性就是一旦事务被提交，改变就是永久的
**重要性**：避免提交的操作丢失
**实现机制**：主要通过重做日志 redo log 和持久化存储来实现，事务提交前，会把所有操作按顺序写到持久化的 redo log 文件中，即使数据库崩溃了，重启时也会把已记录在 redo log、但没同步到数据文件的操作执行一遍来恢复数据。

#### 其他相关概念

> **CAP 定理**
> - 含义：分布式系统设计的核心权衡理论，三者无法同时满足，最多选其二。
> - 组成：
>   - 一致性（Consistency）：分布式系统中所有节点同一时间看到的数据相同。
>   - 可用性（Availability）：合法请求在有限时间内必获响应，系统不拒绝服务。
>   - 分区容错性（Partition Tolerance）：网络分区（部分节点失联）时系统仍能运行，是分布式系统固有属性，通常为必选项。
> - 权衡：
>   - CP（一致性+分区容错性）：网络分区时拒绝部分请求以保数据一致，适用于金融交易等强一致场景。
>   - AP（可用性+分区容错性）：网络分区时继续响应但可能返回旧数据，适用于社交、电商等可用性优先场景。
> 
> 
> **数据质量维度（准确性、有效性、完整性、一致性）**
> - 准确性：数据真实反映现实，如用户年龄为“25”而非“二十”或无效字符。
> - 有效性：数据符合规则约束，如手机号为11位数字、性别仅“男/女”可选。
> - 完整性：数据无关键缺失，如用户表必填的“姓名”“电话”字段不空白。
> - 一致性：同一数据在不同场景/系统中统一，如用户“张三”在订单、会员系统姓名无差异。
> 
> 
> **信息安全 CIA 三元组**
> - 机密性（Confidentiality）：数据仅授权者可访问，如银行密码仅用户自身知晓。
> - 完整性（Integrity）：数据不被未授权篡改，如邮件内容发送后保持原始状态。
> - 可用性（Availability）：数据在需要时可正常访问，如社交软件、支付系统无无故宕机。

### 事务隔离级别

隔离级别主要是为了解决数据并发访问时，出现的脏读，不可重复读和幻读的问题，也就是并发访问时，事务可以在什么时间点看见已提交数据看见未提交或已提交的数据

更准确说是：隔离级别通过约束事务可以在哪个时间点可以看见哪一类（未提交、已提交）的数据，来规避脏读，不可重复读和幻读的问题

#### 脏读 不可重复读 幻读

**脏读**：读的是 “未提交的临时数据”，且该数据最终被回滚

**不可重复读**：同一事务内，两次读 “同一数据”，结果不一样（数据被别人改了且提交了）

**幻读**：同一事务内，两次查 “同一条件的数据”，结果行数不一样（数据被别人增 / 删且提交了）

> 脏读：自己（未提交）→ 别人（别人看到自己的半成品）；
> 不可重复读 / 幻读：别人（已提交）→ 自己（自己被别人的成品打乱）。
> 不可重复读是数据被修改，幻读是数据行数变化

#### 隔离级别

隔离级别依次升高，并行性依次下降

1. **读未提交**：事务可以读别的事务未提交的数据【三个问题都存在】

2. **读已提交**：事务只能读别的事务一提交的数据（Oracle，SQL Server默认级别）【避免脏读】

3. **可重复读**：在同一个事务中，多次读同一数据，结果一致（MySQL的默认级别，通过MVCC（多版本并发控制） 实现快照）【避免脏读和不可重复读】

4. **串行化**：串行化，一个事务一个一个执行，串行执行，性能最差

> MySQL的实现特殊性：MySQL的InnoDB存储引I擎通过多版本并发控制和间隙锁机制，在可重复读级别下很大程度上防止了幻读的发生（虽然不是100%绝对避免所有理论上的幻读场景，但在绝大多数实际场景中避免了）。
> 
> 可以通过如下命令查询MysqI默认的事务隔离级别：`select @@tx_isolstion;`


### 事务控制语句

`BEGINTRANSACTION` / `STARTTRANSACTION`:显式开始一个事务。
`COMMIT`：提交事务，使所有修改永久生效。
`ROLLBACK`:回滚事务，撤销所有未提交的修改。
`SAVEPOINT`：在事务内设置保存点，允许部分回滚。
`ROLLBACKTOSAVEPOINT`:回滚到指定的保存点。
`RELEASESAVEPOINT`:删除保存点。

## 索引

**索引（index）** 是帮助数据库 高效获取数据 的 **数据结构** ，全表扫描效率很低

**索引是提升查询速度的一种数据结构**

> 相关文章：[索引：排序的艺术](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md)
> 
> 总结：
> 
> - 索引的原理是在插入数据时就对数据进行排序，减少了查询时的读写的次数，但插入性能较低
> 
> - 首先现在的索引一般都是B+树结构，因为B+树的层数少，4层就可以存放大约50亿条数据，读写的次数少，性能高
> 
> - 所以说设置索引时最好用自增的数据，UUID这种不是自增的数据，在插入时和自增索引比性能明显下降
> 
> - MySQL单表的索引数没有限制



**优点：**
1. 提高数据查询的效率，降低数据库的IO成本。
2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。

**缺点：**
1. 索引会占用存储空间。
2. 索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。


### 索引的数据结构

MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 **B+Tree** 结构组织的索引。

相关文章：[为什么 MySQL 采用 B+ 树作为索引？](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)

MySQL数据库因为要实现持久化，所有数据都是存在磁盘中的，而从磁盘中进行I/O要比内存中进行I/O操作慢很多，所以减少数据的I/O次数，才能提高查询性能

而因为MySQL的存储是通过存储引擎完成的，所以索引的数据结构也就是存储引擎使用的数据结构，而MySQL的默认存储引擎是InnoDB，InnoDB的索引结构是B+Tree

不考虑存储内容（非叶子节点 / 叶子节点存什么），B 树和 B + 树都是 n 叉树；B + 树的核心额外设计，是给所有叶子节点串联了有序链表，以优化范围查询效率。


> 二叉搜索树/红黑树 大数据量情况下，层级深，检索速度慢



#### B+Tree(多路平衡搜索树)

![alt text](../0.image/01.MySQL/image.png)

**特点：**
* 每一个节点，可以存储多个key（有n个key，就有n个指针）
* 所有的数据都存储在叶子节点，非叶子节点仅用于索引数据
* 叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询

```sql
--创建索引
create [ unique ] index 索引名 on 表名 (字段名,... );

--查看索引
show index from 表名;

--删除索引
drop index 索引名 on 表名;
```

创建索引会自动添加主键索引，唯一值的索引

* 主键字段，在建表时，会自动创建主键索引。
* 添加唯一约束时，数据库实际上会添加唯一索引。


### 索引存储：堆表 & 索引组织表

**堆表** = 无序表 + 非聚簇索引
**索引组织表** = 有序表（聚簇索引）+ 二级索引

#### 堆表
在堆表中，无序表和索引是分开存储的

**无序表** 就是数据按照无序的顺序依次存储在磁盘中

在堆表中，所有的索引都是 **非聚簇索引**

如果给某一个字段添加索引，这个字段的索引会是一个单独的数据结构，里面只存储这个字段在表中对应的地址

**缺点**：当数据更新且原有的空间不够的时候，数据会被写到新的磁盘空间，此时数据的地址就变了，这时候所有索引中对应数据的地址都需要更新

频繁的地址变更会导致索引维护成本升高（每次更新都要修改所有相关索引的叶子节点），进而影响写入性能

#### 索引组织表

在索引组织表中，只有索引一种数据结构，也就是B+树结构

只是 **有序表** 指的是 **聚簇索引**，也可以叫主键索引，也就是对主键进行排序建立的索引，这个索引在数据插入的时候就会自动创建

如果表没有主键，会先选非空唯一字段作为聚簇索引，如果没有这种字段，数据库存储引擎会自动生成隐藏的自增主键作为聚簇索引的键

而其他不是主键的字段建立的索引是 **二级索引**

二级索引中只存储索引字段和索引字段对应的主键值，查询时查到对应的主键值，需要返回主键索引查询对应的具体数据，这种操作叫 **回表**

**缺点**：插入需维护 B + 树顺序（乱序插入易导致节点分裂）

> **总结：**
> 
> - **索引组织表** 适合 **OLTP**（在线事务处理）
> - **堆表** 现在用处不大
> 
> 对比维度 | OLTP（在线事务处理） | OLAP（在线分析处理）
> ------- | ------- | -------
> 核心目标 | 快速处理用户实时事务、保证数据对 | 分析大量历史数据、支持决策（比如报表）
> 数据操作 | 高频小事务（增删改查，以写为主） | 低频大查询（复杂统计，以读为主）
> 数据量 | 每次操作数据量小（一条 / 几条记录） | 每次分析数据量大（百万 / 亿级记录）
> 响应时间 | 毫秒级（用户等得起） | 分钟 / 小时级（分析师可等待）
> 典型场景 | 电商下单、银行转账、社交发消息 | 月度销售报表、用户行为分析、库存预测

#### 【待补充】

##### 二级索引的性能评估

##### 函数索引

### 联合索引

**联合索引** 既可以是 **主键索引** 也可以是 **二级索引**
用户自己创建的联合索引一定是二级索引
如果有联合主键，那也会由联合主键定义自动生成联合索引

#### 三大优势

1. **支持多条件查询**：联合索引(a, b)遵循 “最左前缀原则”，确实能高效匹配a=?（仅用第一个字段）和a=? and b=?（用两个字段）的查询，这是联合索引比单字段索引 “适配更多查询场景” 的核心原因。
2. **避免额外排序**：因联合索引的叶子节点已按a→b的顺序排序，当查询是WHERE a=? ORDER BY b时，数据库直接从索引中按顺序取数据，无需再对b做排序（避免Using filesort），大幅提升性能。
3. **实现索引覆盖**：若查询需要的字段（如SELECT a, b FROM ...）都在联合索引中，数据库无需回表查主键索引，直接从联合索引获取数据，减少磁盘 I/O，这是索引覆盖的核心价值。

### 索引失效情况

**索引依赖 “有序性”，破坏有序性则失效**



## 范式

首先有关范式涉及到两个概念
1. 函数依赖：函数依赖又分为完全依赖和部分依赖。
   - 完全函数依赖：比如一张学生表student(sid,sname,ssex,sage,sdept)，其中sid是主键，可以根据sid推出sname,ssex,sage,sdept，这些属性对主键是完全依赖的
   - 部分函数依赖：比如一张学生表student(sid,cid,sname,sage,sc)，其中sid和cid是主键，可以根据sid和cid推出sc课程成绩，而sname,sage不需要cid，所以sc对主键是完全依赖，而sname,sage对主键是部分依赖
2. 候选码
   - 候选码是能 “精准定位一条记录” 且 “没有冗余属性” 的属性组
   - 候选码中的属性叫做主属性

### 第一范式
表中的每个属性（列）都是原子值（Atomic Value），即属性值不可再拆分为更小的、有意义的子值

### 第二范式
第二范式就是在第一范式的基础上，消除了 **部分函数依赖**
比如把student(sid,cid,sname,sage,sc)
拆成
student_course(sid,cid,sc)
student(sname,sage)

### 第三范式
第三范式就是在第二范式基础上，消除了 **传递函数依赖**
比如一个商品表goods(gid,gname,cid,cname)cid和cname是厂家id和厂家名字
首先这个表是满足第二范式，gname,cid,cname都可以通过主键gid得到
但是cid和cname之间存在传递依赖，cname可以通过cid得到，所以要满足第三范式就要拆分表
拆成
goods(gid,gname,cid)
company(cid,cname)

## 关联查询

首先关联查询主要是通过关联字段（通常是主键和外键）来建立表与表之间的连接

关联查询分为三种
1. 内连接
2. 左外连接
3. 右外连接

**内连接**：返回两张表中都存在也就是关联字段值匹配的行
**左外连接**：返回左表中的所有行，右表有匹配的行时返回，没有匹配的行时返回NULL
**右外连接**：返回右表中的所有行，左表有匹配的行时返回，没有匹配的行时返回NULL

> 右外连接可以通过更换表的顺序转换为左外连接，一般常用左外连接


## 锁

### 全局锁

全局锁开启后，整个数据库就进入只读状态

```sql
-- 开启全局锁
flush tables with read lock

-- 释放全局锁
unlock tables
```

这个适用于 **不支持 可重复读 和 MVCC** 的存储引擎来进行全局逻辑备份

> **逻辑备份**：以逻辑形式（如 SQL 语句）备份整个数据库的所有数据和结构

**支持 可重复读 和 MVCC** 的存储引擎可以根据MVCC的read view，事务快照避免全局锁，并保证数据的一致性

### 表级锁

#### 表锁



#### 元数据锁（MDL）



#### 意向锁



#### AUTO-INC 锁



